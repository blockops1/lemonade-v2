import { ConnectionManager } from '../connection';
import { AggregateStatementPathResult } from '../../../types';
import { ProofType } from '../../../config';
export declare class RpcManager {
    private readonly connectionManager;
    /**
     * Creates an instance of RpcManager.
     * @param {ConnectionManager} connectionManager - The connection manager instance.
     */
    constructor(connectionManager: ConnectionManager);
    /**
     * Retrieves the aggregate statement path from the blockchain via the custom RPC method.
     *
     * @async
     * @function getAggregateStatementPath
     * @param {string} at - The block hash at which to perform the query. Must be a non-empty string.
     * @param {number} domainId - The domain ID for which the aggregation statement path is requested. Must be >= 0.
     * @param {number} aggregationId - The aggregation ID associated with the requested statement path. Must be >= 0.
     * @param {string} statement - The statement hash to query for. Must be a non-empty string.
     * @returns {Promise<AggregateStatementPathResult>} A promise that resolves to the AggregateStatementPathResult.
     * @throws {Error} If any of the inputs are invalid or if the RPC call fails.
     */
    getAggregateStatementPath(at: string, domainId: number, aggregationId: number, statement: string): Promise<AggregateStatementPathResult>;
    /**
     * Retrieves the VK hash for the given proof type and verification key.
     *
     * @async
     * @function getVkHash
     * @param {ProofType} proofType - The proof system type (e.g., groth16, plonky2).
     * @param {string} vk - The verification key string.
     * @returns {Promise<string>} - The resulting VK hash.
     * @throws {Error} If the proof type is unsupported or the RPC call fails.
     */
    getVkHash(proofType: ProofType, vk: unknown): Promise<string>;
}
//# sourceMappingURL=index.d.ts.map