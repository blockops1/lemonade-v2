import { EventEmitter } from 'events';
import { ConnectionManager } from '../connection';
import { NewAggregationReceipt, SubscriptionEntry } from '../../../types';
export declare class EventManager {
    private readonly connectionManager;
    private readonly emitter;
    constructor(connectionManager: ConnectionManager);
    /**
     * Subscribes to specified ZkVerifyEvents.
     * For `NewAggregationReceipt`, `options` can include `domainId` and `aggregationId`.
     * For runtime events (e.g., ProofVerified), options are ignored.
     *
     * @param subscriptions - List of events to subscribe to with optional callback and filtering options.
     * @returns EventEmitter to allow listening to additional internal events (e.g., `Unsubscribe`).
     */
    subscribe(subscriptions?: SubscriptionEntry[]): EventEmitter;
    /**
     * Subscribes to on-chain runtime events using api.query.system.events
     */
    private _subscribeToRuntimeEvent;
    /**
     * Waits for a specific `NewAggregationReceipt` event and returns the result as a NewAggregationReceipt object.
     *
     * @param domainId - The domain ID to listen for.
     * @param aggregationId - The aggregation ID to listen for.
     * @param timeout - Optional timeout value in milliseconds.
     * @returns {Promise<NewAggregationReceipt>} Resolves with the event data when found, or rejects on timeout/error.
     */
    waitForAggregationReceipt(domainId: number, aggregationId: number, timeout?: number): Promise<NewAggregationReceipt>;
    /**
     * Unsubscribes from all active subscriptions.
     */
    unsubscribe(): void;
}
//# sourceMappingURL=index.d.ts.map