import { BatchOptimisticProofMethodMap, BatchProofMethodMap, OptimisticProofMethodMap, ProofMethodMap } from '../../types';
import { ConnectionManager } from '../connection';
export declare class VerificationManager {
    private readonly connectionManager;
    constructor(connectionManager: ConnectionManager);
    /**
     * Creates a builder map for different proof types that can be used for verification.
     * Each proof type returns a `VerificationBuilder` that allows you to chain methods for setting options
     * and finally executing the verification process.
     *
     * @param {string} [accountAddress] - The address of the account performing the verification.
     * @returns {ProofMethodMap} A map of proof types to their corresponding builder methods.
     */
    verify(accountAddress?: string): ProofMethodMap;
    /**
     * Creates a builder map for different proof types that can be used for optimistic verification.
     * Each proof type returns an `OptimisticVerificationBuilder` that allows you to chain methods
     * and finally execute the optimistic verification process.
     *
     * @returns {OptimisticProofMethodMap} A map of proof types to their corresponding builder methods.
     */
    optimisticVerify(): OptimisticProofMethodMap;
    /**
     * Creates a builder map for different proof types that can be used for **batch verification**.
     * Each proof type returns a `BatchVerificationBuilder` allowing you to set options
     * and then submit multiple proofs in a single `batchAll` transaction.
     *
     * @param {string} [accountAddress] - The account address performing the batch verification.
     * @returns {BatchProofMethodMap} A map of proof types to their batch verification builder methods.
     */
    batchVerify(accountAddress?: string): BatchProofMethodMap;
    /**
     * Creates a builder map for different proof types that can be used for **optimistic batch verification**.
     * Each proof type returns a `BatchOptimisticVerificationBuilder` that builds and dry-runs a `batchAll` transaction
     * to ensure all proofs would pass without submitting to the chain.
     *
     * @returns {BatchOptimisticProofMethodMap} A map of proof types to their optimistic batch verification builders.
     */
    batchOptimisticVerify(): BatchOptimisticProofMethodMap;
    /**
     * Factory method to create a `VerificationBuilder` for the given proof type.
     * The builder allows for chaining options and executing the verification process.
     *
     * @param {AllProofConfigs} proofOptions - The proof options object containing the proof type and its specific options.
     *   - Must include a valid `proofType` and associated options depending on the proof type:
     *     - Groth16: Requires `library` and `curve`.
     *     - Plonky2: Requires `compressed` (boolean) and `hashFunction`.
     *     - Risc0: Requires `version`.
     *     - Ultraplonk / ProofOfSql: No specific options required.
     *
     * @param {string} [accountAddress] - The account to use for verification.
     *   - If a `string`, it represents the account address.
     *   - If `undefined`, the first available account is used by default.
     *
     * @returns {VerificationBuilder} A new instance of `VerificationBuilder` configured with the provided proof options and account.
     *
     * @throws {Error} If the provided proof options are invalid or incomplete.
     * @private
     */
    private createVerifyBuilder;
    /**
     * Factory method to create an `OptimisticVerificationBuilder` for the given proof type.
     * This builder allows for configuring and executing the optimistic verification process.
     *
     * @param {AllProofConfigs} proofOptions - The proof options object containing the proof type and its specific options.
     *   - Must include a valid `proofType` and associated options depending on the proof type:
     *     - Groth16: Requires `library` and `curve`.
     *     - Plonky2: Requires `compressed` (boolean) and `hashFunction`.
     *     - Risc0: Requires `version`.
     *     - Ultraplonk / ProofOfSql: No specific options required.
     *
     * @param accountAddress
     * @returns {OptimisticVerificationBuilder} A new instance of `OptimisticVerificationBuilder` configured with the provided proof options.
     *
     * @throws {Error} If the provided proof options are invalid or incomplete.
     * @private
     */
    private createOptimisticVerifyBuilder;
    /**
     * Factory method to create a `BatchVerificationBuilder` for the given proof type.
     * This builder enables chaining configuration methods and executing a batch of on-chain verifications
     * using a single `batchAll` transaction.
     *
     * @param {ProofOptions} proofOptions - Configuration for the proof type and related parameters.
     * @param {string} [accountAddress] - Optional account address to sign and submit the transaction.
     * @returns {BatchVerificationBuilder} A builder for executing batch verification.
     *
     * @throws {Error} If the provided proof options are invalid.
     * @private
     */
    private createBatchVerifyBuilder;
    /**
     * Factory method to create a `BatchVerificationBuilder` for the given proof type.
     * This builder enables chaining configuration methods and executing a batch of on-chain verifications
     * using a single `batchAll` transaction.
     *
     * @param {ProofOptions} proofOptions - Configuration for the proof type and related parameters.
     * @param {string} [accountAddress] - Optional account address to sign and submit the transaction.
     * @returns {BatchVerificationBuilder} A builder for executing batch verification.
     *
     * @throws {Error} If the provided proof options are invalid.
     * @private
     */
    private createBatchOptimisticVerifyBuilder;
    /**
     * Executes the verification process with the provided proof options and proof data or pre-built extrinsic.
     * This method is intended to be called by the `VerificationBuilder`.
     *
     * @param {VerifyOptions} options - The options for the verification process, including:
     *   - `proofOptions` {AllProofOptions}: Contains the proof type and associated options depending on the type.
     *   - `accountAddress` {string} [optional]: The account address to use for the verification.
     *   - `nonce` {number} [optional]: The nonce for the transaction, if applicable.
     *   - `registeredVk` {boolean} [optional]: Whether to use a registered verification key.
     *   - `domainId` {number} [optional]: The domain ID for domain-specific operations.
     *
     * @param {VerifyInput} input - The verification input, which must be one of the following:
     *   - `proofData`: An array of proof parameters (proof, public signals, and verification key).
     *   - `extrinsic`: A pre-built `SubmittableExtrinsic`.
     *   - Ensure only one of these options is provided within the `VerifyInput`.
     *
     * @returns {Promise<{events: EventEmitter, transactionResult: Promise<VerifyTransactionInfo>}>}
     *   A promise that resolves with an object containing:
     *   - `events`: An `EventEmitter` instance for real-time verification events.
     *   - `transactionResult`: A promise that resolves to the final transaction information once verification is complete.
     *
     * @throws {Error} If the verification fails or the proof options are invalid.
     * @private
     */
    private executeVerify;
    /**
     * Executes the optimistic verification process using the provided proof options and input.
     * This method is intended to be called by the `OptimisticVerificationBuilder`.
     *
     * @param {VerifyOptions} options - The options for the verification process, including:
     *   - `proofOptions` {AllProofOptions}: Contains the proof type and associated options depending on the type.
     *   - `accountAddress` {string} [optional]: The account address to use for the verification.
     *   - `nonce` {number} [optional]: The nonce for the transaction, if applicable.
     *   - `registeredVk` {boolean} [optional]: Whether to use a registered verification key.
     *   - `domainId` {number} [optional]: The domain ID for domain-specific operations.
     * @param {VerifyInput} input - The verification input, which must be one of the following:
     *   - `proofData`: An array of proof parameters (proof, public signals, and verification key).
     *   - `extrinsic`: A pre-built `SubmittableExtrinsic`.
     *   - Ensure only one of these options is provided within the `VerifyInput`.
     *
     * @returns {Promise<{ success: boolean; message: string }>}
     *   A promise that resolves to an object containing:
     *   - `success`: A boolean indicating whether the optimistic verification was successful.
     *   - `message`: A message providing additional details about the verification result.
     *
     * @throws {Error} If the session is in read-only mode.
     * @throws {Error} If not connected to a custom network.
     * @private
     */
    private executeOptimisticVerify;
    /**
     * Executes a full on-chain batch verification of multiple proofs.
     * Internally constructs a `batchAll` extrinsic and listens for success or error events.
     *
     * @param {VerifyOptions} options - Options including proof type, vk registration flag, etc.
     * @param {VerifyInput[]} input - An array of proof inputs (either proofData or prebuilt extrinsic).
     * @returns {Promise<{events: EventEmitter, transactionResult: Promise<BatchVerifyTransactionInfo>}>}
     *   A promise resolving to:
     *   - `events`: An EventEmitter for lifecycle events (broadcast, includedInBlock, finalized, etc).
     *   - `transactionResult`: The final batch verification result after on-chain execution.
     *
     * @throws {Error} If verification is called while in read-only mode.
     */
    private executeBatchVerify;
    /**
     * Executes a dry-run of a batch verification to simulate success or failure without submitting.
     * This method wraps `api.rpc.system.dryRun` around the `batchAll` extrinsic built from the proof list.
     *
     * @param {VerifyOptions} options - Options including proof type and domain configuration.
     * @param {VerifyInput[]} input - List of proofs to simulate in the batch.
     * @returns {Promise<{ success: boolean; message: string }>} A dry-run result summary.
     *
     * @throws {Error} If not connected to a custom network or called in read-only mode.
     */
    private executeBatchOptimisticVerify;
}
//# sourceMappingURL=index.d.ts.map