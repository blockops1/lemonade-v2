import { handleTransaction } from "../../utils/transactions/index.js";
import { TransactionType, ZkVerifyEvents } from "../../enums.js";
import { format } from "../format/index.js";
import { createSubmitProofExtrinsic } from "../extrinsic/index.js";
import { getKeyringAccountIfAvailable } from "../../utils/helpers/index.js";
export const verify = async (connection, options, emitter, input) => {
  const {
    api
  } = connection;
  try {
    const selectedAccount = getKeyringAccountIfAvailable(connection, options.accountAddress);
    if (input.domainId != null) {
      options.domainId = input.domainId;
    }
    const transaction = (() => {
      if ('proofData' in input && input.proofData) {
        const {
          proof,
          publicSignals,
          vk
        } = input.proofData;
        const formatted = format(options.proofOptions, proof, publicSignals, vk, options.registeredVk);
        return createSubmitProofExtrinsic(api, options.proofOptions.proofType, formatted, input.domainId);
      }
      if ('extrinsic' in input && input.extrinsic) {
        return input.extrinsic;
      }
      throw new Error('Invalid input: Either proofData or extrinsic must be provided.');
    })();
    const result = selectedAccount ? await handleTransaction(api, transaction, selectedAccount, undefined, emitter, options, TransactionType.Verify) : 'injector' in connection ? await handleTransaction(api, transaction, connection.accountAddress, connection.injector.signer, emitter, options, TransactionType.Verify) : (() => {
      throw new Error('Unsupported connection type.');
    })();
    return result;
  } catch (error) {
    emitter.emit(ZkVerifyEvents.ErrorEvent, error);
    emitter.removeAllListeners();
    throw error;
  }
};