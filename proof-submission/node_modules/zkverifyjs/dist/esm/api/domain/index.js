import { TransactionType, ZkVerifyEvents } from "../../enums.js";
import { getKeyringAccountIfAvailable, normalizeDeliveryFromOptions } from "../../utils/helpers/index.js";
import EventEmitter from 'events';
import { handleTransaction } from "../../utils/transactions/index.js";
export const registerDomain = (connection, aggregationSize, queueSize = 16, domainOptions, signerAccount) => {
  if (aggregationSize <= 0 || aggregationSize > 128) throw new Error(`registerDomain aggregationSize must be between 1 and 128`);
  if (queueSize <= 0 || queueSize > 16) throw new Error(`registerDomain queueSize must be between 1 and 16`);
  if (domainOptions.aggregateRules === undefined) throw new Error(`registerDomain deliveryOptions.aggregateRules must be defined`);
  const delivery = normalizeDeliveryFromOptions(domainOptions);
  const {
    api
  } = connection;
  const registerExtrinsic = api.tx.aggregate.registerDomain(aggregationSize, queueSize, domainOptions.aggregateRules, delivery, domainOptions.deliveryOwner);
  const emitter = new EventEmitter();
  const transactionResult = performTransaction(connection, registerExtrinsic, TransactionType.DomainRegistration, emitter, signerAccount);
  return {
    events: emitter,
    transactionResult
  };
};
export const holdDomain = (connection, domainId, signerAccount) => {
  if (domainId < 0) throw new Error(`holdDomain domainId must be greater than 0`);
  const holdExtrinsic = connection.api.tx.aggregate.holdDomain(domainId);
  const emitter = new EventEmitter();
  const transactionResult = performTransaction(connection, holdExtrinsic, TransactionType.DomainHold, emitter, signerAccount);
  return {
    events: emitter,
    transactionResult
  };
};
export const unregisterDomain = (connection, domainId, signerAccount) => {
  if (domainId < 0) throw new Error(`unregisterDomain domainId must be greater than 0`);
  const unregisterExtrinsic = connection.api.tx.aggregate.unregisterDomain(domainId);
  const emitter = new EventEmitter();
  const transactionResult = performTransaction(connection, unregisterExtrinsic, TransactionType.DomainUnregister, emitter, signerAccount);
  return {
    events: emitter,
    transactionResult
  };
};
export const aggregate = (connection, domainId, aggregationId, signerAccount) => {
  const registerExtrinsic = connection.api.tx.aggregate.aggregate(domainId, aggregationId);
  const emitter = new EventEmitter();
  const transactionResult = performTransaction(connection, registerExtrinsic, TransactionType.Aggregate, emitter, signerAccount);
  return {
    events: emitter,
    transactionResult
  };
};
export const performTransaction = async (connection, extrinsic, transactionType, emitter, signerAccount) => {
  const {
    api
  } = connection;
  const selectedAccount = getKeyringAccountIfAvailable(connection, signerAccount);
  try {
    const result = await (async () => {
      if (selectedAccount) {
        return await handleTransaction(api, extrinsic, selectedAccount, undefined, emitter, {}, transactionType);
      } else if ('injector' in connection) {
        const {
          signer
        } = connection.injector;
        return await handleTransaction(api, extrinsic, connection.accountAddress, signer, emitter, {}, transactionType);
      } else {
        throw new Error('Unsupported connection type.');
      }
    })();
    emitter.removeAllListeners();
    return result;
  } catch (error) {
    emitter.emit(ZkVerifyEvents.ErrorEvent, error);
    emitter.removeAllListeners();
    throw error;
  }
};