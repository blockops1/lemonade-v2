import { TransactionStatus, ZkVerifyEvents } from "../../enums.js";
import { handleError } from "./errors/index.js";
import { safeEmit } from "../helpers/index.js";
import { initializeTransactionInfo } from "./transactionInfo/index.js";
import { handleFinalized, handleInBlock } from "./handlers/index.js";
/**
 * Handles transaction execution, signing, and event handling.
 */
export const handleTransaction = async (api, submitExtrinsic, account, signer, emitter, options, transactionType, batchCount) => {
  const transactionInfo = initializeTransactionInfo(transactionType, options, batchCount);
  return new Promise((resolve, reject) => {
    const cancelTransaction = error => {
      if (transactionInfo.status !== TransactionStatus.Error) {
        transactionInfo.status = TransactionStatus.Error;
        try {
          const errObj = error instanceof Error ? error : new Error(String(error));
          handleError(emitter, api, transactionInfo, errObj, true);
        } catch (err) {
          reject(err);
          return;
        }
      }
      reject(error);
    };
    const finalizeTransaction = async result => {
      if (transactionInfo.status === TransactionStatus.Error) return;
      try {
        await handleFinalized(api, transactionInfo, result.dispatchError, emitter, transactionType);
        resolve(transactionInfo);
      } catch (error) {
        cancelTransaction(error);
      }
    };
    performSignAndSend(submitExtrinsic, account, signer ? {
      signer,
      nonce: options.nonce
    } : {
      nonce: options.nonce
    }, async result => {
      if (transactionInfo.status === TransactionStatus.Error) return;
      try {
        if (result.status.isBroadcast) {
          safeEmit(emitter, ZkVerifyEvents.Broadcast, {
            txHash: result.txHash.toString()
          });
        }
        if (result.status.isInBlock) {
          transactionInfo.txHash = result.txHash.toString();
          transactionInfo.blockHash = result.status.asInBlock.toString();
          await handleInBlock(api, result.events, transactionInfo, emitter, transactionType);
        }
        if (result.status.isFinalized) {
          await finalizeTransaction(result);
        } else if (result.status.isInvalid) {
          throw new Error('Transaction is invalid.');
        }
      } catch (error) {
        cancelTransaction(error);
      }
    }).catch(error => {
      cancelTransaction(error);
    });
  });
};
/**
 * Handles signing and sending transactions.
 */
export function performSignAndSend(submitExtrinsic, account, options, callback) {
  if (typeof account === 'string' && options?.signer) {
    return submitExtrinsic.signAndSend(account, options, callback);
  } else if (typeof account !== 'string') {
    return options ? submitExtrinsic.signAndSend(account, options, callback) : submitExtrinsic.signAndSend(account, callback);
  }
  throw new Error('Unsupported account or signer type.');
}