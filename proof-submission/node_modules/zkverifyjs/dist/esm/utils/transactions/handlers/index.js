import { TransactionStatus, TransactionType, ZkVerifyEvents } from "../../../enums.js";
import { handleTransactionEvents } from "../events/index.js";
import { safeEmit } from "../../helpers/index.js";
import { handleError } from "../errors/index.js";
/**
 * Handles "In Block" transaction updates.
 */
export const handleInBlock = async (api, events, transactionInfo, emitter, transactionType) => {
  if (transactionInfo.status === TransactionStatus.Error) return;
  transactionInfo.status = TransactionStatus.InBlock;
  const updatedTransactionInfo = handleTransactionEvents(api, events, transactionInfo, emitter, transactionType);
  Object.assign(transactionInfo, updatedTransactionInfo);
  safeEmit(emitter, ZkVerifyEvents.IncludedInBlock, transactionInfo);
};
/**
 * Handles "Finalized" transaction updates.
 */
export const handleFinalized = async (api, transactionInfo, dispatchError, emitter, transactionType) => {
  if (transactionInfo.status === TransactionStatus.Error) return;
  if (dispatchError) {
    handleError(emitter, api, transactionInfo, dispatchError);
    return;
  }
  transactionInfo.status = TransactionStatus.Finalized;
  switch (transactionType) {
    case TransactionType.Verify:
      {
        const info = transactionInfo;
        const hasDomainId = !!info.domainId;
        const hasAggregationId = !!info.aggregationId;
        if (!hasDomainId || hasAggregationId) {
          safeEmit(emitter, ZkVerifyEvents.Finalized, info);
        } else {
          safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
            ...info,
            error: 'Finalized but no aggregation ID found.'
          });
        }
        break;
      }
    case TransactionType.BatchVerify:
      {
        const info = transactionInfo;
        if (typeof info.batchCount === 'number' && info.batchCount > 0) {
          safeEmit(emitter, ZkVerifyEvents.Finalized, info);
        } else {
          safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
            ...info,
            error: 'Finalized but batchCount is missing or invalid.'
          });
        }
        break;
      }
    case TransactionType.VKRegistration:
      {
        const info = transactionInfo;
        if (info.statementHash) {
          safeEmit(emitter, ZkVerifyEvents.Finalized, info);
        } else {
          safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
            ...info,
            error: 'Finalized but no statement hash found.'
          });
        }
        break;
      }
    case TransactionType.DomainRegistration:
      {
        const info = transactionInfo;
        if (info.domainId !== undefined) {
          safeEmit(emitter, ZkVerifyEvents.NewDomain, {
            domainId: info.domainId
          });
          safeEmit(emitter, ZkVerifyEvents.Finalized, info);
        } else {
          safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
            ...info,
            error: 'Finalized but no domain ID found.'
          });
        }
        break;
      }
    case TransactionType.DomainHold:
    case TransactionType.DomainUnregister:
      {
        const info = transactionInfo;
        if (info.domainState !== undefined) {
          safeEmit(emitter, ZkVerifyEvents.DomainStateChanged, {
            domainId: info.domainId,
            domainState: info.domainState
          });
          safeEmit(emitter, ZkVerifyEvents.Finalized, info);
        } else {
          safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
            ...info,
            error: 'Finalized but no domain state returned.'
          });
        }
        break;
      }
    case TransactionType.Aggregate:
      {
        const info = transactionInfo;
        if (info.domainId !== undefined || info.aggregationId !== undefined || info.receipt !== undefined) {
          safeEmit(emitter, ZkVerifyEvents.Finalized, info);
        } else {
          const missingFields = ['domainId', 'aggregationId', 'receipt'].filter(key => info[key] === undefined).join(', ');
          safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
            ...info,
            error: `Finalized but missing fields: ${missingFields}`
          });
        }
        break;
      }
    default:
      {
        console.warn('Unknown transaction type finalized:', transactionType);
        break;
      }
  }
};