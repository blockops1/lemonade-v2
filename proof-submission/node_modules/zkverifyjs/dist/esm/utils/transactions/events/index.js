import { TransactionType, ZkVerifyEvents } from "../../../enums.js";
import { getProofPallet, safeEmit } from "../../helpers/index.js";
export const handleTransactionEvents = (api, events, transactionInfo, emitter, transactionType) => {
  let statementHash;
  let aggregationId;
  let statement;
  let domainId;
  let domainState;
  let receipt;
  let myExtrinsicIndex;
  events.forEach(({
    event,
    phase
  }) => {
    if (phase.isApplyExtrinsic && myExtrinsicIndex === undefined) {
      myExtrinsicIndex = phase.asApplyExtrinsic.toNumber();
      transactionInfo.extrinsicIndex = myExtrinsicIndex;
    }
    if (!phase.isApplyExtrinsic || phase.asApplyExtrinsic.toNumber() !== transactionInfo.extrinsicIndex) {
      return;
    }
    if (event.section === 'transactionPayment' && event.method === 'TransactionFeePaid') {
      transactionInfo.feeInfo = {
        payer: event.data[0].toString(),
        actualFee: event.data[1].toString(),
        tip: event.data[2].toString(),
        paysFee: 'Yes'
      };
    }
    if (event.section === 'system' && event.method === 'ExtrinsicSuccess') {
      const dispatchInfo = event.data[0];
      transactionInfo.weightInfo = {
        refTime: dispatchInfo.weight.refTime?.toString(),
        proofSize: dispatchInfo.weight.proofSize?.toString()
      };
      transactionInfo.txClass = dispatchInfo.class.toString();
      if (transactionInfo.feeInfo) {
        transactionInfo.feeInfo.paysFee = dispatchInfo.paysFee.toString();
      }
    }
    if (event.section === 'system' && event.method === 'ExtrinsicFailed') {
      const [dispatchError] = event.data;
      throw dispatchError;
    }
    if (transactionType === TransactionType.Verify && event.section === getProofPallet(transactionInfo.proofType) && event.method === 'ProofVerified') {
      statement = event.data[0].toString();
      safeEmit(emitter, ZkVerifyEvents.ProofVerified, {
        statement
      });
    }
    if (transactionType === TransactionType.Verify && event.section === 'aggregate' && event.method === 'NewProof') {
      const [eventStatement, eventDomainId, eventAggregationId] = event.data;
      statement = eventStatement.toString();
      domainId = Number(eventDomainId.toString());
      aggregationId = Number(eventAggregationId.toString());
      safeEmit(emitter, ZkVerifyEvents.NewProof, {
        statement,
        domainId,
        aggregationId
      });
    }
    if (transactionType === TransactionType.VKRegistration && event.section === getProofPallet(transactionInfo.proofType) && event.method === 'VkRegistered') {
      statementHash = event.data[0].toString();
      safeEmit(emitter, ZkVerifyEvents.VkRegistered, {
        statementHash
      });
    }
    if ((transactionType === TransactionType.DomainHold || transactionType === TransactionType.DomainUnregister) && event.section === 'aggregate' && event.method === 'DomainStateChanged') {
      const [eventDomainId, state] = event.data;
      domainId = Number(eventDomainId.toString());
      domainState = state.toString();
      safeEmit(emitter, ZkVerifyEvents.DomainStateChanged, {
        domainId,
        domainState
      });
    }
    if (transactionType === TransactionType.DomainRegistration && event.section === 'aggregate' && event.method === 'NewDomain') {
      domainId = Number(event.data[0].toString());
      safeEmit(emitter, ZkVerifyEvents.NewDomain, {
        domainId
      });
    }
    if (transactionType === TransactionType.Aggregate && event.section === 'aggregate' && event.method === 'NewAggregationReceipt') {
      const [eventDomainId, eventAggregationId, eventReceipt] = event.data;
      domainId = Number(eventDomainId.toString());
      aggregationId = Number(eventAggregationId.toString());
      receipt = eventReceipt.toString();
      safeEmit(emitter, ZkVerifyEvents.NewAggregationReceipt, {
        domainId,
        aggregationId,
        receipt
      });
    }
  });
  switch (transactionType) {
    case TransactionType.Aggregate:
      return {
        ...transactionInfo,
        domainId,
        aggregationId,
        receipt
      };
    case TransactionType.DomainRegistration:
      return {
        ...transactionInfo,
        domainId
      };
    case TransactionType.DomainHold:
    case TransactionType.DomainUnregister:
      return {
        ...transactionInfo,
        domainId,
        domainState
      };
    case TransactionType.Verify:
      return {
        ...transactionInfo,
        statement,
        domainId,
        aggregationId
      };
    case TransactionType.VKRegistration:
    default:
      return {
        ...transactionInfo,
        statementHash
      };
  }
};