"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.batchVerify = void 0;
const transactions_1 = require("../../utils/transactions");
const enums_1 = require("../../enums");
const format_1 = require("../format");
const extrinsic_1 = require("../extrinsic");
const helpers_1 = require("../../utils/helpers");
const batchVerify = async (connection, options, emitter, input) => {
    const { api } = connection;
    const selectedAccount = (0, helpers_1.getKeyringAccountIfAvailable)(connection, options.accountAddress);
    const calls = [];
    let formatError = null;
    for (let i = 0; i < input.length; i++) {
        const item = input[i];
        try {
            if ('proofData' in item && item.proofData) {
                const { proof, publicSignals, vk } = item.proofData;
                const formatted = (0, format_1.format)(options.proofOptions, proof, publicSignals, vk, options.registeredVk ?? false);
                const extrinsic = (0, extrinsic_1.createSubmitProofExtrinsic)(api, options.proofOptions.proofType, formatted, item.domainId ?? undefined);
                calls.push(extrinsic);
            }
            else if ('extrinsic' in item && item.extrinsic) {
                calls.push(item.extrinsic);
            }
            else {
                throw new Error('Missing both proofData and extrinsic.');
            }
        }
        catch (err) {
            formatError = new Error(`Failed to format proof at batch index ${i}: ${err.message}`);
            break;
        }
    }
    if (formatError) {
        return Promise.reject(formatError);
    }
    if (calls.length === 0) {
        const err = new Error('No valid proofs provided for batch verification.');
        emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, err);
        emitter.removeAllListeners();
        throw err;
    }
    const batchTransaction = api.tx.utility.batchAll(calls);
    try {
        const result = selectedAccount
            ? await (0, transactions_1.handleTransaction)(api, batchTransaction, selectedAccount, undefined, emitter, options, enums_1.TransactionType.BatchVerify, input.length)
            : 'injector' in connection
                ? await (0, transactions_1.handleTransaction)(api, batchTransaction, connection.accountAddress, connection.injector.signer, emitter, options, enums_1.TransactionType.BatchVerify, input.length)
                : (() => {
                    throw new Error('Unsupported connection type.');
                })();
        return result;
    }
    catch (error) {
        emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, error);
        emitter.removeAllListeners();
        throw error;
    }
};
exports.batchVerify = batchVerify;
