"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.performTransaction = exports.aggregate = exports.unregisterDomain = exports.holdDomain = exports.registerDomain = void 0;
const enums_1 = require("../../enums");
const helpers_1 = require("../../utils/helpers");
const events_1 = __importDefault(require("events"));
const transactions_1 = require("../../utils/transactions");
const registerDomain = (connection, aggregationSize, queueSize = 16, domainOptions, signerAccount) => {
    if (aggregationSize <= 0 || aggregationSize > 128)
        throw new Error(`registerDomain aggregationSize must be between 1 and 128`);
    if (queueSize <= 0 || queueSize > 16)
        throw new Error(`registerDomain queueSize must be between 1 and 16`);
    if (domainOptions.aggregateRules === undefined)
        throw new Error(`registerDomain deliveryOptions.aggregateRules must be defined`);
    const delivery = (0, helpers_1.normalizeDeliveryFromOptions)(domainOptions);
    const { api } = connection;
    const registerExtrinsic = api.tx.aggregate.registerDomain(aggregationSize, queueSize, domainOptions.aggregateRules, delivery, domainOptions.deliveryOwner);
    const emitter = new events_1.default();
    const transactionResult = (0, exports.performTransaction)(connection, registerExtrinsic, enums_1.TransactionType.DomainRegistration, emitter, signerAccount);
    return { events: emitter, transactionResult };
};
exports.registerDomain = registerDomain;
const holdDomain = (connection, domainId, signerAccount) => {
    if (domainId < 0)
        throw new Error(`holdDomain domainId must be greater than 0`);
    const holdExtrinsic = connection.api.tx.aggregate.holdDomain(domainId);
    const emitter = new events_1.default();
    const transactionResult = (0, exports.performTransaction)(connection, holdExtrinsic, enums_1.TransactionType.DomainHold, emitter, signerAccount);
    return { events: emitter, transactionResult };
};
exports.holdDomain = holdDomain;
const unregisterDomain = (connection, domainId, signerAccount) => {
    if (domainId < 0)
        throw new Error(`unregisterDomain domainId must be greater than 0`);
    const unregisterExtrinsic = connection.api.tx.aggregate.unregisterDomain(domainId);
    const emitter = new events_1.default();
    const transactionResult = (0, exports.performTransaction)(connection, unregisterExtrinsic, enums_1.TransactionType.DomainUnregister, emitter, signerAccount);
    return { events: emitter, transactionResult };
};
exports.unregisterDomain = unregisterDomain;
const aggregate = (connection, domainId, aggregationId, signerAccount) => {
    const registerExtrinsic = connection.api.tx.aggregate.aggregate(domainId, aggregationId);
    const emitter = new events_1.default();
    const transactionResult = (0, exports.performTransaction)(connection, registerExtrinsic, enums_1.TransactionType.Aggregate, emitter, signerAccount);
    return { events: emitter, transactionResult };
};
exports.aggregate = aggregate;
const performTransaction = async (connection, extrinsic, transactionType, emitter, signerAccount) => {
    const { api } = connection;
    const selectedAccount = (0, helpers_1.getKeyringAccountIfAvailable)(connection, signerAccount);
    try {
        const result = await (async () => {
            if (selectedAccount) {
                return await (0, transactions_1.handleTransaction)(api, extrinsic, selectedAccount, undefined, emitter, {}, transactionType);
            }
            else if ('injector' in connection) {
                const { signer } = connection.injector;
                return await (0, transactions_1.handleTransaction)(api, extrinsic, connection.accountAddress, signer, emitter, {}, transactionType);
            }
            else {
                throw new Error('Unsupported connection type.');
            }
        })();
        emitter.removeAllListeners();
        return result;
    }
    catch (error) {
        emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, error);
        emitter.removeAllListeners();
        throw error;
    }
};
exports.performTransaction = performTransaction;
