"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTransaction = void 0;
exports.performSignAndSend = performSignAndSend;
const enums_1 = require("../../enums");
const errors_1 = require("./errors");
const helpers_1 = require("../helpers");
const transactionInfo_1 = require("./transactionInfo");
const handlers_1 = require("./handlers");
/**
 * Handles transaction execution, signing, and event handling.
 */
const handleTransaction = async (api, submitExtrinsic, account, signer, emitter, options, transactionType, batchCount) => {
    const transactionInfo = (0, transactionInfo_1.initializeTransactionInfo)(transactionType, options, batchCount);
    return new Promise((resolve, reject) => {
        const cancelTransaction = (error) => {
            if (transactionInfo.status !== enums_1.TransactionStatus.Error) {
                transactionInfo.status = enums_1.TransactionStatus.Error;
                try {
                    const errObj = error instanceof Error ? error : new Error(String(error));
                    (0, errors_1.handleError)(emitter, api, transactionInfo, errObj, true);
                }
                catch (err) {
                    reject(err);
                    return;
                }
            }
            reject(error);
        };
        const finalizeTransaction = async (result) => {
            if (transactionInfo.status === enums_1.TransactionStatus.Error)
                return;
            try {
                await (0, handlers_1.handleFinalized)(api, transactionInfo, result.dispatchError, emitter, transactionType);
                resolve(transactionInfo);
            }
            catch (error) {
                cancelTransaction(error);
            }
        };
        performSignAndSend(submitExtrinsic, account, signer ? { signer, nonce: options.nonce } : { nonce: options.nonce }, async (result) => {
            if (transactionInfo.status === enums_1.TransactionStatus.Error)
                return;
            try {
                if (result.status.isBroadcast) {
                    (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Broadcast, {
                        txHash: result.txHash.toString(),
                    });
                }
                if (result.status.isInBlock) {
                    transactionInfo.txHash = result.txHash.toString();
                    transactionInfo.blockHash = result.status.asInBlock.toString();
                    await (0, handlers_1.handleInBlock)(api, result.events, transactionInfo, emitter, transactionType);
                }
                if (result.status.isFinalized) {
                    await finalizeTransaction(result);
                }
                else if (result.status.isInvalid) {
                    throw new Error('Transaction is invalid.');
                }
            }
            catch (error) {
                cancelTransaction(error);
            }
        }).catch((error) => {
            cancelTransaction(error);
        });
    });
};
exports.handleTransaction = handleTransaction;
/**
 * Handles signing and sending transactions.
 */
function performSignAndSend(submitExtrinsic, account, options, callback) {
    if (typeof account === 'string' && options?.signer) {
        return submitExtrinsic.signAndSend(account, options, callback);
    }
    else if (typeof account !== 'string') {
        return options
            ? submitExtrinsic.signAndSend(account, options, callback)
            : submitExtrinsic.signAndSend(account, callback);
    }
    throw new Error('Unsupported account or signer type.');
}
