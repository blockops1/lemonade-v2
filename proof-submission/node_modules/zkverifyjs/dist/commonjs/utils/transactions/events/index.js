"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTransactionEvents = void 0;
const enums_1 = require("../../../enums");
const helpers_1 = require("../../helpers");
const handleTransactionEvents = (api, events, transactionInfo, emitter, transactionType) => {
    let statementHash;
    let aggregationId;
    let statement;
    let domainId;
    let domainState;
    let receipt;
    let myExtrinsicIndex;
    events.forEach(({ event, phase }) => {
        if (phase.isApplyExtrinsic && myExtrinsicIndex === undefined) {
            myExtrinsicIndex = phase.asApplyExtrinsic.toNumber();
            transactionInfo.extrinsicIndex = myExtrinsicIndex;
        }
        if (!phase.isApplyExtrinsic ||
            phase.asApplyExtrinsic.toNumber() !== transactionInfo.extrinsicIndex) {
            return;
        }
        if (event.section === 'transactionPayment' &&
            event.method === 'TransactionFeePaid') {
            transactionInfo.feeInfo = {
                payer: event.data[0].toString(),
                actualFee: event.data[1].toString(),
                tip: event.data[2].toString(),
                paysFee: 'Yes',
            };
        }
        if (event.section === 'system' && event.method === 'ExtrinsicSuccess') {
            const dispatchInfo = event.data[0];
            transactionInfo.weightInfo = {
                refTime: dispatchInfo.weight.refTime?.toString(),
                proofSize: dispatchInfo.weight.proofSize?.toString(),
            };
            transactionInfo.txClass = dispatchInfo.class.toString();
            if (transactionInfo.feeInfo) {
                transactionInfo.feeInfo.paysFee = dispatchInfo.paysFee.toString();
            }
        }
        if (event.section === 'system' && event.method === 'ExtrinsicFailed') {
            const [dispatchError] = event.data;
            throw dispatchError;
        }
        if (transactionType === enums_1.TransactionType.Verify &&
            event.section ===
                (0, helpers_1.getProofPallet)(transactionInfo.proofType) &&
            event.method === 'ProofVerified') {
            statement = event.data[0].toString();
            (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ProofVerified, { statement });
        }
        if (transactionType === enums_1.TransactionType.Verify &&
            event.section === 'aggregate' &&
            event.method === 'NewProof') {
            const [eventStatement, eventDomainId, eventAggregationId] = event.data;
            statement = eventStatement.toString();
            domainId = Number(eventDomainId.toString());
            aggregationId = Number(eventAggregationId.toString());
            (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.NewProof, {
                statement,
                domainId,
                aggregationId,
            });
        }
        if (transactionType === enums_1.TransactionType.VKRegistration &&
            event.section ===
                (0, helpers_1.getProofPallet)(transactionInfo.proofType) &&
            event.method === 'VkRegistered') {
            statementHash = event.data[0].toString();
            (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.VkRegistered, { statementHash });
        }
        if ((transactionType === enums_1.TransactionType.DomainHold ||
            transactionType === enums_1.TransactionType.DomainUnregister) &&
            event.section === 'aggregate' &&
            event.method === 'DomainStateChanged') {
            const [eventDomainId, state] = event.data;
            domainId = Number(eventDomainId.toString());
            domainState = state.toString();
            (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.DomainStateChanged, {
                domainId,
                domainState,
            });
        }
        if (transactionType === enums_1.TransactionType.DomainRegistration &&
            event.section === 'aggregate' &&
            event.method === 'NewDomain') {
            domainId = Number(event.data[0].toString());
            (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.NewDomain, { domainId });
        }
        if (transactionType === enums_1.TransactionType.Aggregate &&
            event.section === 'aggregate' &&
            event.method === 'NewAggregationReceipt') {
            const [eventDomainId, eventAggregationId, eventReceipt] = event.data;
            domainId = Number(eventDomainId.toString());
            aggregationId = Number(eventAggregationId.toString());
            receipt = eventReceipt.toString();
            (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.NewAggregationReceipt, {
                domainId,
                aggregationId,
                receipt,
            });
        }
    });
    switch (transactionType) {
        case enums_1.TransactionType.Aggregate:
            return {
                ...transactionInfo,
                domainId,
                aggregationId,
                receipt,
            };
        case enums_1.TransactionType.DomainRegistration:
            return {
                ...transactionInfo,
                domainId,
            };
        case enums_1.TransactionType.DomainHold:
        case enums_1.TransactionType.DomainUnregister:
            return {
                ...transactionInfo,
                domainId,
                domainState,
            };
        case enums_1.TransactionType.Verify:
            return {
                ...transactionInfo,
                statement,
                domainId,
                aggregationId,
            };
        case enums_1.TransactionType.VKRegistration:
        default:
            return {
                ...transactionInfo,
                statementHash,
            };
    }
};
exports.handleTransactionEvents = handleTransactionEvents;
