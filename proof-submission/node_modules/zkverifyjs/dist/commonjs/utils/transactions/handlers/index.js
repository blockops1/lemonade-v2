"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFinalized = exports.handleInBlock = void 0;
const enums_1 = require("../../../enums");
const events_1 = require("../events");
const helpers_1 = require("../../helpers");
const errors_1 = require("../errors");
/**
 * Handles "In Block" transaction updates.
 */
const handleInBlock = async (api, events, transactionInfo, emitter, transactionType) => {
    if (transactionInfo.status === enums_1.TransactionStatus.Error)
        return;
    transactionInfo.status = enums_1.TransactionStatus.InBlock;
    const updatedTransactionInfo = (0, events_1.handleTransactionEvents)(api, events, transactionInfo, emitter, transactionType);
    Object.assign(transactionInfo, updatedTransactionInfo);
    (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.IncludedInBlock, transactionInfo);
};
exports.handleInBlock = handleInBlock;
/**
 * Handles "Finalized" transaction updates.
 */
const handleFinalized = async (api, transactionInfo, dispatchError, emitter, transactionType) => {
    if (transactionInfo.status === enums_1.TransactionStatus.Error)
        return;
    if (dispatchError) {
        (0, errors_1.handleError)(emitter, api, transactionInfo, dispatchError);
        return;
    }
    transactionInfo.status = enums_1.TransactionStatus.Finalized;
    switch (transactionType) {
        case enums_1.TransactionType.Verify: {
            const info = transactionInfo;
            const hasDomainId = !!info.domainId;
            const hasAggregationId = !!info.aggregationId;
            if (!hasDomainId || hasAggregationId) {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Finalized, info);
            }
            else {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                    ...info,
                    error: 'Finalized but no aggregation ID found.',
                });
            }
            break;
        }
        case enums_1.TransactionType.BatchVerify: {
            const info = transactionInfo;
            if (typeof info.batchCount === 'number' && info.batchCount > 0) {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Finalized, info);
            }
            else {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                    ...info,
                    error: 'Finalized but batchCount is missing or invalid.',
                });
            }
            break;
        }
        case enums_1.TransactionType.VKRegistration: {
            const info = transactionInfo;
            if (info.statementHash) {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Finalized, info);
            }
            else {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                    ...info,
                    error: 'Finalized but no statement hash found.',
                });
            }
            break;
        }
        case enums_1.TransactionType.DomainRegistration: {
            const info = transactionInfo;
            if (info.domainId !== undefined) {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.NewDomain, {
                    domainId: info.domainId,
                });
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Finalized, info);
            }
            else {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                    ...info,
                    error: 'Finalized but no domain ID found.',
                });
            }
            break;
        }
        case enums_1.TransactionType.DomainHold:
        case enums_1.TransactionType.DomainUnregister: {
            const info = transactionInfo;
            if (info.domainState !== undefined) {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.DomainStateChanged, {
                    domainId: info.domainId,
                    domainState: info.domainState,
                });
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Finalized, info);
            }
            else {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                    ...info,
                    error: 'Finalized but no domain state returned.',
                });
            }
            break;
        }
        case enums_1.TransactionType.Aggregate: {
            const info = transactionInfo;
            if (info.domainId !== undefined ||
                info.aggregationId !== undefined ||
                info.receipt !== undefined) {
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.Finalized, info);
            }
            else {
                const missingFields = ['domainId', 'aggregationId', 'receipt']
                    .filter((key) => info[key] === undefined)
                    .join(', ');
                (0, helpers_1.safeEmit)(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                    ...info,
                    error: `Finalized but missing fields: ${missingFields}`,
                });
            }
            break;
        }
        default: {
            console.warn('Unknown transaction type finalized:', transactionType);
            break;
        }
    }
};
exports.handleFinalized = handleFinalized;
