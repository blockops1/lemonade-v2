"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeEmit = exports.getSelectedAccount = exports.interpretDryRunResponse = void 0;
exports.waitForNodeToSync = waitForNodeToSync;
exports.getProofProcessor = getProofProcessor;
exports.getProofPallet = getProofPallet;
exports.checkReadOnly = checkReadOnly;
exports.bindMethods = bindMethods;
exports.getKeyringAccountIfAvailable = getKeyringAccountIfAvailable;
exports.normalizeDeliveryFromOptions = normalizeDeliveryFromOptions;
exports.isGroth16Config = isGroth16Config;
exports.isPlonky2Config = isPlonky2Config;
exports.isRisc0Config = isRisc0Config;
exports.isUltraplonkConfig = isUltraplonkConfig;
const enums_1 = require("../../enums");
const config_1 = require("../../config");
const errors_1 = require("../transactions/errors");
/**
 * Waits for the zkVerify node to sync.
 * @param api - The ApiPromise instance.
 * @returns A promise that resolves when the node is synced.
 */
async function waitForNodeToSync(api) {
    let isSyncing = true;
    while (isSyncing) {
        const health = await api.rpc.system.health();
        isSyncing = health.isSyncing.isTrue;
        if (isSyncing) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
        }
    }
}
function getProofProcessor(proofType) {
    const config = config_1.proofConfigurations[proofType];
    if (!config) {
        throw new Error(`No config found for Proof Processor: ${proofType}`);
    }
    return config.processor;
}
function getProofPallet(proofType) {
    const config = config_1.proofConfigurations[proofType];
    if (!config) {
        throw new Error(`No config found for Proof Pallet: ${proofType}`);
    }
    return config.pallet;
}
function checkReadOnly(connection) {
    if ((!('accounts' in connection) ||
        ('accounts' in connection && connection.accounts.size === 0)) &&
        !('injector' in connection)) {
        throw new Error('This action requires an active account. The session is currently in read-only mode because no account is associated with it. Please provide an account at session start, or add one to the current session using `addAccount`.');
    }
}
/**
 * Interprets a dry run response and returns whether it was successful and any error message.
 * @param api - The Polkadot.js API instance.
 * @param resultHex - The hex-encoded response from a dry run.
 * @returns An object containing `success` (boolean) and `message` (string).
 */
const interpretDryRunResponse = async (api, resultHex) => {
    try {
        const responseBytes = Uint8Array.from(Buffer.from(resultHex.replace('0x', ''), 'hex'));
        if (responseBytes[0] === 0x00 && responseBytes[1] === 0x00) {
            return { success: true, message: 'Optimistic Verification Successful!' };
        }
        if (responseBytes[0] === 0x00 && responseBytes[1] === 0x01) {
            const dispatchError = api.registry.createType('DispatchError', responseBytes.slice(2));
            const errorMessage = (0, errors_1.decodeDispatchError)(api, dispatchError);
            return { success: false, message: errorMessage };
        }
        return {
            success: false,
            message: `Unexpected response format: ${resultHex}`,
        };
    }
    catch (error) {
        return {
            success: false,
            message: `Failed to interpret dry run result: ${error}`,
        };
    }
};
exports.interpretDryRunResponse = interpretDryRunResponse;
/**
 * Binds all methods from the source object to the target object,
 * preserving the original `this` context.
 *
 * Throws an error if a method with the same name already exists on the target.
 *
 * @param target - The object to bind methods to.
 * @param source - The object containing the methods to bind.
 *
 * @throws {Error} If a method with the same name already exists on the target.
 */
function bindMethods(target, source) {
    const propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(source));
    for (const name of propertyNames) {
        const method = source[name];
        if (typeof method === 'function' && name !== 'constructor') {
            if (name in target) {
                throw new Error(`❌ Method collision detected: "${name}". Binding aborted.`);
            }
            target[name] = method.bind(source);
        }
    }
}
/**
 * Retrieves the selected account from the connection based on the provided account address.
 * If no account address is provided, it defaults to the first available account.
 *
 * @param {AccountConnection} connection - The connection containing account information.
 * @param {string | undefined} accountAddress - The optional account address to retrieve.
 * @returns {KeyringPair} - The selected account.
 * @throws {Error} If the account is not found.
 */
const getSelectedAccount = (connection, accountAddress) => {
    let selectedAccount;
    if (accountAddress) {
        selectedAccount = connection.accounts.get(accountAddress);
    }
    else {
        selectedAccount = Array.from(connection.accounts.values())[0];
    }
    if (!selectedAccount) {
        throw new Error(`Account ${accountAddress ?? ''} not found in session.`);
    }
    return selectedAccount;
};
exports.getSelectedAccount = getSelectedAccount;
/**
 * Retrieves the selected `KeyringPair` from the given connection if it is an `AccountConnection`.
 *
 * - If the connection has local `accounts` (i.e., it's an `AccountConnection`), it uses the provided `accountAddress`
 *   to select the appropriate account via `getSelectedAccount`.
 * - If the connection is a `WalletConnection`, returns `undefined`.
 *
 * @param {AccountConnection | WalletConnection} connection - The connection object which may contain accounts.
 * @param {string} [accountAddress] - Optional address of the account to select.
 * @returns {KeyringPair | undefined} - The selected `KeyringPair` if available, otherwise `undefined`.
 */
function getKeyringAccountIfAvailable(connection, accountAddress) {
    return 'accounts' in connection
        ? (0, exports.getSelectedAccount)(connection, accountAddress)
        : undefined;
}
/**
 * Converts a `DeliveryInput` into a properly formatted `Delivery` object.
 * Supports either a `None` variant or a `Hyperbridge` delivery configuration.
 *
 * @returns A `Delivery` object formatted for on-chain use.
 * @throws {Error} If required fields for Hyperbridge delivery are missing or invalid.
 * @param options
 */
function normalizeDeliveryFromOptions(options) {
    if (options.destination === enums_1.Destination.None) {
        return { None: null };
    }
    const { deliveryInput } = options;
    return {
        destination: {
            Hyperbridge: {
                destinationChain: deliveryInput.destinationChain,
                destination_module: deliveryInput.destination_module,
                timeout: deliveryInput.timeout,
            },
        },
        price: deliveryInput.price,
    };
}
/**
 * Safe wrapper for emitting events without crashing.
 */
const safeEmit = (emitter, event, data) => {
    try {
        emitter.emit(event, data);
    }
    catch (error) {
        console.debug(`Failed to emit event ${event}:`, error);
    }
};
exports.safeEmit = safeEmit;
/**
 * Type guard for Groth16Config
 */
function isGroth16Config(options) {
    return (options.proofType === config_1.ProofType.groth16 &&
        options.config !== undefined &&
        options.config.library !== undefined &&
        options.config.curve !== undefined);
}
/**
 * Type guard for Plonky2Config
 */
function isPlonky2Config(options) {
    return (options.proofType === config_1.ProofType.plonky2 &&
        options.config !== undefined &&
        options.config.hashFunction !== undefined);
}
/**
 * Type guard for Risc0Config
 */
function isRisc0Config(options) {
    return (options.proofType === config_1.ProofType.risc0 &&
        options.config !== undefined &&
        options.config.version !== undefined);
}
/**
 * Type guard for Ultraplonk Config
 */
function isUltraplonkConfig(options) {
    return (options.proofType === config_1.ProofType.ultraplonk &&
        options.config !== undefined &&
        options.config.numberOfPublicInputs !== undefined);
}
// ADD_NEW_PROOF_TYPE if it has a config options object
