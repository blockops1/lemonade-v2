"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateProofTypeOptions = validateProofTypeOptions;
const config_1 = require("../../config");
const helpers_1 = require("../../utils/helpers");
/**
 * Validates the options provided for a given proof type.
 * @throws {Error} - If the validation fails.
 */
function validateProofTypeOptions(options) {
    const { proofType } = options;
    if (!proofType) {
        throw new Error('Proof type is required.');
    }
    switch (proofType) {
        case config_1.ProofType.groth16:
            if (!(0, helpers_1.isGroth16Config)(options)) {
                throw new Error(`Proof type '${proofType}' requires both 'library' and 'curve' options.`);
            }
            break;
        case config_1.ProofType.plonky2:
            if (!(0, helpers_1.isPlonky2Config)(options)) {
                throw new Error(`Proof type '${proofType}' requires 'compressed' (boolean) and 'hashFunction' options.`);
            }
            break;
        case config_1.ProofType.risc0:
            if (!(0, helpers_1.isRisc0Config)(options)) {
                throw new Error(`Proof type '${proofType}' requires a 'version' option.`);
            }
            break;
        case config_1.ProofType.ultraplonk:
            if (!(0, helpers_1.isUltraplonkConfig)(options)) {
                throw new Error(`Proof type '${proofType}' requires a 'numberOfPublicInputs' option.`);
            }
            break;
        case config_1.ProofType.proofofsql:
        case config_1.ProofType.fflonk:
            // No specific options required for these proof types
            break;
        //ADD_NEW_PROOF_TYPE config validation per proof type
        default:
            void options;
            throw new Error(`Unsupported proof type: ${options.proofType}`);
    }
}
