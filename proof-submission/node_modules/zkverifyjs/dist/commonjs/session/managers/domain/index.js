"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainManager = void 0;
const domain_1 = require("../../../api/domain");
const helpers_1 = require("../../../utils/helpers");
class DomainManager {
    /**
     * Creates an instance of DomainManager.
     * @param {ConnectionManager} connectionManager - The connection manager instance.
     */
    constructor(connectionManager) {
        this.connectionManager = connectionManager;
    }
    /**
     * Registers a new domain with the given configuration.
     *
     * @param aggregationSize - Number of statements per aggregation.
     * @param queueSize - Max number of aggregations in the queue (default is 16).
     * @param domainOptions - options object containing additional params such as destination and security rules.
     * @param signerAccount - Optional address of the account signing the transaction if multiple have been added to the session.
     * @returns {{ events: EventEmitter; transactionResult: Promise<RegisterDomainTransactionInfo> }}
     * An object containing an event emitter and a promise that resolves to a DomainTransactionInfo object when the call completes.
     * @throws {Error} If the session is read-only.
     */
    registerDomain(aggregationSize, queueSize = 16, domainOptions, signerAccount) {
        (0, helpers_1.checkReadOnly)(this.connectionManager.connectionDetails);
        return (0, domain_1.registerDomain)(this.connectionManager.connectionDetails, aggregationSize, queueSize, domainOptions, signerAccount);
    }
    aggregate(domainId, aggregationId, signerAccount) {
        (0, helpers_1.checkReadOnly)(this.connectionManager.connectionDetails);
        return (0, domain_1.aggregate)(this.connectionManager.connectionDetails, domainId, aggregationId, signerAccount);
    }
    /**
     * Places a hold on a domain.
     * @param {number} domainId - The ID of the domain to hold.
     * @param accountAddress - optional address of the account making the transaction
     * @returns {{ events: EventEmitter; transactionResult: Promise<DomainTransactionInfo> }}
     * An object containing an event emitter and a promise that resolves to a DomainTransactionInfo object when the call completes.
     * @throws {Error} If the connection is read-only.
     */
    holdDomain(domainId, accountAddress) {
        (0, helpers_1.checkReadOnly)(this.connectionManager.connectionDetails);
        return (0, domain_1.holdDomain)(this.connectionManager.connectionDetails, domainId, accountAddress);
    }
    /**
     * Unregisters a domain.
     * @param {number} domainId - The ID of the domain to unregister.
     * @param accountAddress - optional address of the account making the transaction
     * @returns {{ events: EventEmitter; transactionResult: Promise<DomainTransactionInfo> }}
     * An object containing an event emitter and a promise that resolves to a DomainTransactionInfo object when the call completes.
     * @throws {Error} If the connection is read-only.
     */
    unregisterDomain(domainId, accountAddress) {
        (0, helpers_1.checkReadOnly)(this.connectionManager.connectionDetails);
        return (0, domain_1.unregisterDomain)(this.connectionManager.connectionDetails, domainId, accountAddress);
    }
}
exports.DomainManager = DomainManager;
